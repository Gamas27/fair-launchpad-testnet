{"abi":[{"type":"function","name":"burn","inputs":[{"name":"tokenId","type":"uint256","internalType":"uint256"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"mint","inputs":[{"name":"params","type":"tuple","internalType":"struct INonfungiblePositionManager.MintParams","components":[{"name":"token0","type":"address","internalType":"address"},{"name":"token1","type":"address","internalType":"address"},{"name":"fee","type":"uint24","internalType":"uint24"},{"name":"tickLower","type":"int24","internalType":"int24"},{"name":"tickUpper","type":"int24","internalType":"int24"},{"name":"amount0Desired","type":"uint256","internalType":"uint256"},{"name":"amount1Desired","type":"uint256","internalType":"uint256"},{"name":"amount0Min","type":"uint256","internalType":"uint256"},{"name":"amount1Min","type":"uint256","internalType":"uint256"},{"name":"recipient","type":"address","internalType":"address"},{"name":"deadline","type":"uint256","internalType":"uint256"}]}],"outputs":[{"name":"tokenId","type":"uint256","internalType":"uint256"},{"name":"liquidity","type":"uint128","internalType":"uint128"},{"name":"amount0","type":"uint256","internalType":"uint256"},{"name":"amount1","type":"uint256","internalType":"uint256"}],"stateMutability":"payable"},{"type":"function","name":"safeTransferFrom","inputs":[{"name":"from","type":"address","internalType":"address"},{"name":"to","type":"address","internalType":"address"},{"name":"tokenId","type":"uint256","internalType":"uint256"}],"outputs":[],"stateMutability":"nonpayable"}],"bytecode":{"object":"0x","sourceMap":"","linkReferences":{}},"deployedBytecode":{"object":"0x","sourceMap":"","linkReferences":{}},"methodIdentifiers":{"burn(uint256)":"42966c68","mint((address,address,uint24,int24,int24,uint256,uint256,uint256,uint256,address,uint256))":"88316456","safeTransferFrom(address,address,uint256)":"42842e0e"},"rawMetadata":"{\"compiler\":{\"version\":\"0.8.28+commit.7893614a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"},{\"internalType\":\"uint256\",\"name\":\"amount0Desired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1Desired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount0Min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1Min\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct INonfungiblePositionManager.MintParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"liquidity\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"burn(uint256)\":{\"details\":\"The approval is cleared when the token is burned\",\"params\":{\"tokenId\":\"The ID of the token to burn\"}},\"mint((address,address,uint24,int24,int24,uint256,uint256,uint256,uint256,address,uint256))\":{\"details\":\"Call this method if the pool exists and is initialized. Note that if the pool is created but not initialized a method does not exist, i.e. the pool is assumed to be initialized. As a result, the method will revert if the pool is not initialized.\",\"params\":{\"params\":\"The params necessary to mint a position, encoded as `MintParams` in calldata\"},\"returns\":{\"amount0\":\"The amount of token0\",\"amount1\":\"The amount of token1\",\"liquidity\":\"The amount of liquidity for this position\",\"tokenId\":\"The ID of the token that represents the minted position\"}},\"safeTransferFrom(address,address,uint256)\":{\"details\":\"Throws unless `msg.sender` is the current owner, an authorized operator, or the approved address for this NFT. Throws if `from` is the current owner. Throws if `to` is the zero address. Throws if `tokenId` is not a valid NFT. When transfer is complete, this function checks if `to` is a smart contract (code size > 0). If so, it calls `onERC721Received` on `to` and throws if the return value is not `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`.\",\"params\":{\"from\":\"The current owner of the NFT\",\"to\":\"The new owner\",\"tokenId\":\"The NFT to transfer\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"burn(uint256)\":{\"notice\":\"Burns a token ID, which deletes it from the NFT contract\"},\"mint((address,address,uint24,int24,int24,uint256,uint256,uint256,uint256,address,uint256))\":{\"notice\":\"Creates a new position wrapped in a NFT\"},\"safeTransferFrom(address,address,uint256)\":{\"notice\":\"Transfers the ownership of an NFT from one address to another address\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/interfaces/INonfungiblePositionManager.sol\":\"INonfungiblePositionManager\"},\"evmVersion\":\"prague\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[\":@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\":erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\":forge-std/=lib/openzeppelin-contracts/lib/forge-std/src/\",\":halmos-cheatcodes/=lib/openzeppelin-contracts/lib/halmos-cheatcodes/src/\",\":openzeppelin-contracts/=lib/openzeppelin-contracts/\"],\"viaIR\":true},\"sources\":{\"src/interfaces/INonfungiblePositionManager.sol\":{\"keccak256\":\"0xe76c9e9502db952d4e88ab947a181075464988bc7bfe4404c71478fdf0ffd4d9\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://c706173f69ef431370661774b5dcc4c47f4ccbc8dec620b839fab8484520ee52\",\"dweb:/ipfs/QmdpB9dCYLCDAb5cwHGtfDbye1b29VQ8UMzUdsGRHKksL3\"]}},\"version\":1}","metadata":{"compiler":{"version":"0.8.28+commit.7893614a"},"language":"Solidity","output":{"abi":[{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"stateMutability":"nonpayable","type":"function","name":"burn"},{"inputs":[{"internalType":"struct INonfungiblePositionManager.MintParams","name":"params","type":"tuple","components":[{"internalType":"address","name":"token0","type":"address"},{"internalType":"address","name":"token1","type":"address"},{"internalType":"uint24","name":"fee","type":"uint24"},{"internalType":"int24","name":"tickLower","type":"int24"},{"internalType":"int24","name":"tickUpper","type":"int24"},{"internalType":"uint256","name":"amount0Desired","type":"uint256"},{"internalType":"uint256","name":"amount1Desired","type":"uint256"},{"internalType":"uint256","name":"amount0Min","type":"uint256"},{"internalType":"uint256","name":"amount1Min","type":"uint256"},{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"}]}],"stateMutability":"payable","type":"function","name":"mint","outputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"uint128","name":"liquidity","type":"uint128"},{"internalType":"uint256","name":"amount0","type":"uint256"},{"internalType":"uint256","name":"amount1","type":"uint256"}]},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"}],"stateMutability":"nonpayable","type":"function","name":"safeTransferFrom"}],"devdoc":{"kind":"dev","methods":{"burn(uint256)":{"details":"The approval is cleared when the token is burned","params":{"tokenId":"The ID of the token to burn"}},"mint((address,address,uint24,int24,int24,uint256,uint256,uint256,uint256,address,uint256))":{"details":"Call this method if the pool exists and is initialized. Note that if the pool is created but not initialized a method does not exist, i.e. the pool is assumed to be initialized. As a result, the method will revert if the pool is not initialized.","params":{"params":"The params necessary to mint a position, encoded as `MintParams` in calldata"},"returns":{"amount0":"The amount of token0","amount1":"The amount of token1","liquidity":"The amount of liquidity for this position","tokenId":"The ID of the token that represents the minted position"}},"safeTransferFrom(address,address,uint256)":{"details":"Throws unless `msg.sender` is the current owner, an authorized operator, or the approved address for this NFT. Throws if `from` is the current owner. Throws if `to` is the zero address. Throws if `tokenId` is not a valid NFT. When transfer is complete, this function checks if `to` is a smart contract (code size > 0). If so, it calls `onERC721Received` on `to` and throws if the return value is not `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.","params":{"from":"The current owner of the NFT","to":"The new owner","tokenId":"The NFT to transfer"}}},"version":1},"userdoc":{"kind":"user","methods":{"burn(uint256)":{"notice":"Burns a token ID, which deletes it from the NFT contract"},"mint((address,address,uint24,int24,int24,uint256,uint256,uint256,uint256,address,uint256))":{"notice":"Creates a new position wrapped in a NFT"},"safeTransferFrom(address,address,uint256)":{"notice":"Transfers the ownership of an NFT from one address to another address"}},"version":1}},"settings":{"remappings":["@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/","erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/","forge-std/=lib/openzeppelin-contracts/lib/forge-std/src/","halmos-cheatcodes/=lib/openzeppelin-contracts/lib/halmos-cheatcodes/src/","openzeppelin-contracts/=lib/openzeppelin-contracts/"],"optimizer":{"enabled":true,"runs":200},"metadata":{"bytecodeHash":"ipfs"},"compilationTarget":{"src/interfaces/INonfungiblePositionManager.sol":"INonfungiblePositionManager"},"evmVersion":"prague","libraries":{},"viaIR":true},"sources":{"src/interfaces/INonfungiblePositionManager.sol":{"keccak256":"0xe76c9e9502db952d4e88ab947a181075464988bc7bfe4404c71478fdf0ffd4d9","urls":["bzz-raw://c706173f69ef431370661774b5dcc4c47f4ccbc8dec620b839fab8484520ee52","dweb:/ipfs/QmdpB9dCYLCDAb5cwHGtfDbye1b29VQ8UMzUdsGRHKksL3"],"license":"MIT"}},"version":1},"id":17}